.. _component_MD_SB:

#########################################################################
Hierarchical Strategy for Simple One-Component Polymer Melts: md-softblob
#########################################################################

.. sidebar:: Software Technical Information

  The information in this section describes ESPResSo++ as a whole.
  Information specific to the additions in this module are in subsequent
  sections.

  Languages:
    Python (2.7) and C++

  Documentation Tools:
    Sphinx and Doxygen

  Application Documentation:
    http://espressopp.github.io/

  Relevant Training Material:
    https://github.com/espressopp/espressopp/tree/master/examples

  Licence
    GNU General Public License

.. contents:: :local:

Reference [1]_ describes the principles of a hierarchical strategy to
equilibrate simple one-component polymer melts described in terms of
atomistic or coarse-grained (bead-spring) models. The present module
is the central part of our implementation of this method in
ESPResSO++.

.. Add technical info as a sidebar and allow text below to wrap around it

Purpose of Module
_________________

.. Give a brief overview of why the module is/was being created.

To study the properties of polymer melts by numerical simulations,
equilibrated configurations must be prepared. However, the relaxation
time for high molecular weight polymer melts is huge and increases,
according to reptation theory, with the third power of the molecular
weight. Hence, an effective method for decreasing the equilibration
time is required. The hierarchical strategy pioneered in Ref. [1]_ is
a particularly suitable way to do this. The present module is the
central part that controls a suite of programs which realize this
method within the framework of the simulation package ESPResSO++.

To decrease the relaxation time, microscopic monomers are
coarse-grained (CG) by mapping each subchain with :math:`N_{b}` monomers
onto a soft blob. The CG system is then characterized by a much
lower molecular weight and thus is equilibrated quickly. One thus
obtains a configuration that is equilibrated on large scales
but does not provide information about the structure on smaller
(i.e. more fine-grained (FG)) scales.

To obtain the latter, the resolution is step-by-step increased by
recursively applying a fine-graining procedure to the previous (more
coarse-grained) level. In such a fine-graining step, each CG polymer
chain is replaced with a more fine-grained chain, by dividing a CG
blob into several FG blobs. In the last step, microscopic monomers are
reinserted into their CG blobs.

The resulting set of FG blobs is set up in such a way that its
conformation is consistent with the conformation at the more
coarse-grained level. After this setup, the local FG conformation is
relaxed into a local equilibrium, again consistent with the (fixed) CG
blobs.

The present module implements the actual coarse-graining step, which
is therefore described in more detail:

A polymer chain, originally consisting of :math:`N`
monomers, is replaced by a coarse-grained (CG) chain consisting of
:math:`N/N_{b}` soft blobs linked by a harmonic bond potential,
:math:`V_{bond}=3 k_{B}T d^{2}/2b_{CG}^2`, and an angular bond-bending
potential :math:`V_{bend}=k_{B}T k_{bend}(1 + \cos(\theta))/2`. Here
:math:`d` is the distance and :math:`\theta` is the angle between
consecutive bonds. The interactions between non-bonded soft blobs are
taken into account by a repulsive pair potential :math:`V_{nb}=k_{B}T
\epsilon U_{G}(r_{ij})`. Here :math:`r_{ij}` is the center-to-center
distance between the two blobs, :math:`U_{G}(r_{ij})` is a Gaussian
function with variance :math:`\overline{\sigma}^2 = \sigma_{i}^2 + \sigma_{j}^2` and
:math:`\sigma_{i}` is the gyration radius of blob number
:math:`i`. The gyration radius :math:`\sigma` is in turn
fluctuating. This fluctuation is controlled by the potential
:math:`V_{sphere}=k_{B}T \, (a_{1}N_{b}^3\sigma^{-6} +
a_{2}N_{b}^{-1}\sigma^{2} + a_{3}\sigma^{-3})`.
Equilibrated configurations of soft blobs are generated by
Molecular Dynamics (MD) simulations based on the above model.

Within the module, the following classes have been implemented or
modified:

* A ``VSpherePair`` class for calculating
  :math:`V_{nb}=k_{B}T \epsilon U_{G}(r_{ij})`
      
* A ``VSphereSelf`` class for calculating :math:`V_{sphere}=k_{B}T \,
  (a_{1}N_{b}^3\sigma^{-6} + a_{2}N_{b}^{-1}\sigma^{2} +
  a_{3}\sigma^{-3})`

* A ``Particle`` class for comunicating the property "radius"
  between different cores

* A ``LangevinThermostatOnRadius`` class for simulating
  the fluctuations of the radii of the blobs

Background Information
______________________

The implementation of this module is based on ESPResSO++. You can
learn about ESPResSO++ from the following links:

* ESPResSO++ documentation: http://espressopp.github.io/ESPResSo++.pdf
* ESPResSO++ source code: https://github.com/espressopp/espressopp

Testing
_______

Explanation of installation:

* https://github.com/espressopp/espressopp

After installing this module, it can be tested by a Python script
found under the following link:

* https://github.com/espressopp/espressopp/tree/master/testsuite/langevin_thermostat_on_radius

Source Code
___________

This module has been merged into ESPResSo++:

* https://github.com/espressopp/espressopp/pull/168
* https://github.com/espressopp/espressopp/pull/169
* https://github.com/espressopp/espressopp/pull/170
* https://github.com/espressopp/espressopp/pull/176

References
___________
.. Here are the URL references used
.. [1] : http://pubs.acs.org/doi/abs/10.1021/mz5000015,
   preprint available via
   https://arxiv.org/abs/1610.07511
   