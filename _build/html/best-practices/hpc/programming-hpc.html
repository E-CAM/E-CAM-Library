<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Programming for HPC &#8212; E-CAM Software Library 0.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/ecam_logo.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Accessing HPC Resources in Europe" href="hpc-resources.html" />
    <link rel="prev" title="Future HPC Hardware in Europe" href="euro-hardware-roadmap.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="hpc-resources.html" title="Accessing HPC Resources in Europe"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="euro-hardware-roadmap.html" title="Future HPC Hardware in Europe"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">E-CAM Software Library 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Scientific Software Best Practices</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="hpc_programming_guidelines.html" accesskey="U">HPC Programming Guidelines</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="programming-for-hpc">
<span id="programming-paradigms"></span><h1>Programming for HPC<a class="headerlink" href="#programming-for-hpc" title="Permalink to this headline">¶</a></h1>
<div class="section" id="c-17">
<h2>C++17<a class="headerlink" href="#c-17" title="Permalink to this headline">¶</a></h2>
<p>C++17 is the name for the most recent revision of the <a class="reference external" href="https://en.wikipedia.org/wiki/ISO/IEC_14882">ISO/IEC 14882</a>
standard for the C++ programming language.</p>
<p>The previous C++ versions show very limited parallel processing capabilities when using mutli/many core architectures.
This situation will change with the C++17, in which the parallelised version of <a class="reference external" href="https://en.wikipedia.org/wiki/Standard_Template_Library">Standard Template Library</a> is
included. The STL is a software library for C++ programming which has 4 components: Algorithms, Containers, Functors
and Iterators. <a class="reference external" href="https://insidehpc.com/2017/05/parallel-stl/">&#8220;Parallel STL advances the evolution of C++, adding vectorization and parallelization capabilities
without resorting to nonstandard or proprietary extensions, and leading to code modernization and the development of
new applications on modern architectures.&#8221;</a></p>
<p>A <a class="reference external" href="https://en.wikipedia.org/wiki/C%2B%2B11#Multithreading_memory_model">multi-threading programming model for C++</a> is
supported since C++11.</p>
</div>
<div class="section" id="fortran-2015">
<h2>Fortran 2015<a class="headerlink" href="#fortran-2015" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="http://fortranwiki.org/fortran/show/Fortran+2015">Fortran 2015</a> is a minor revision of Fortran 2008 (which was when
Fortran became a Partioned Global Address Space (PGAS) language with the introduction of <a class="reference external" href="https://en.wikipedia.org/wiki/Coarray_Fortran">coarrays</a>). The revisions mostly target additional parallelisation features and
increased interoperability with C.</p>
<p>Most Fortran-based software E-CAM sees in practice is implemented in Fortran 95 and there appears to be little awareness
of the parallel features of the latest Fortran standards. E-CAM is considering organising a workshop that addresses
this lack of awareness (similar to the &#8220;<a class="reference external" href="https://www.cranfield.ac.uk/courses/short/aerospace/software-engineering-and-parellel-programming-in-modern-fortan">Software Engineering and Parallel Programming in Modern Fortran</a>&#8221;
held at the Cranfield University).</p>
<p>It should be noted that <a class="reference external" href="http://fortranwiki.org/fortran/show/Compiler+Support+for+Modern+Fortran">compiler support for the latest Fortran standards is limited</a>. This is most likely due to the fact
that Fortran is not widely used outside of the scientific research (limiting its commercial scope).</p>
</div>
<div class="section" id="the-potential-role-of-python">
<h2>The (potential) role of Python<a class="headerlink" href="#the-potential-role-of-python" title="Permalink to this headline">¶</a></h2>
<p>Given that it is an interpreted language (i.e., it is only compiled at runtime), Python is not usually discussed much
in the HPC space since there is limited scope for control over many factors that influence performance. Where we
are observing a lot of growth is where applications are being written in languages like C++ under the hood but are
intended to be primarily used via their Python interfaces.</p>
<p>This is a valuable, and user friendly, development model that allows users to leverage Python for fast prototyping while
maintaining the potential for high performance application codes.</p>
<p>A warning to would be users: <a class="reference external" href="https://pythonclock.org/">Python 2 will stop being developed in 2020</a> so please make
sure that your code is Python3 compliant.</p>
</div>
<div class="section" id="open-standards">
<h2>Open Standards<a class="headerlink" href="#open-standards" title="Permalink to this headline">¶</a></h2>
<p>We describe here some of the open standards that are most likely to be leveraged on next generation HPCresources.</p>
<p><strong>MPI</strong></p>
<p>Now more than 25 years old, Message Passing Interface (MPI) is still with us and remains the de facto standard for
internode communication (though it is not the only option, alternatives such as <a class="reference external" href="https://gasnet.lbl.gov/">GASNet</a>
exist). <a class="reference external" href="http://mpi-forum.org/docs/mpi-3.1/mpi31-report.pdf">MPI-3.1</a> was approved
by the MPI Forum on June 4, 2015. It was mainly an errata release for MPI 3.0 which included some important enhancements
to MPI:</p>
<ul class="simple">
<li>Nonblocking collectives</li>
<li>Sparse and scalable irregular collectives</li>
<li>Enhancements to one-sided communication (very important for extreme scalability)</li>
<li>Shared memory extensions (on clusters of SMP nodes)</li>
<li>Fortran interface</li>
</ul>
<p>Maintaining awareness of the <a class="reference external" href="https://www.lrz.de/services/compute/courses/x_lecturenotes/Parallel_Programming_Languages_Workshop/MPI.pdf">scope of past and future updates to the MPI standard</a> is
important since it is the latest features that target the latest architectural developments.</p>
<p><strong>OpenMP</strong></p>
<p>OpenMP is also 20 years old and remains the most portable option for on-node workloads. The standard has introduced
new features to deal with increasing node-level heterogeneity (device offloading, such as for the GPU, in
particular) and varied workloads (task level parallelism).</p>
<p>From GCC 6.1, OpenMP 4.5 is fully supported for C and C++ (with Fortran support coming in the GCC 7 series). The
<a class="reference external" href="http://www.openmp.org/resources/openmp-compilers/">level of OpenMP support among other compilers</a> varies
significantly.</p>
<p><strong>OpenACC</strong></p>
<p><a class="reference external" href="https://www.openacc.org/">OpenACC</a> (for open accelerators) is a programming standard for parallel computing
developed by Cray, CAPS, Nvidia
and PGI. The standard is designed to simplify parallel programming of heterogeneous CPU/GPU systems. Since the
paradigm is very similar to the latest OpenMP specs, a future merger into OpenMP is not unlikely.
It should be noted that CUDA (with the <a class="reference external" href="http://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html">nvcc compiler</a>) is still the most commonly used (and highest performing)
library for programming NVIDIA GPUs.</p>
<p><strong>OpenCL</strong></p>
<p>Open Computing Language (OpenCL) is a framework for writing programs that execute across heterogeneous platforms
consisting of central processing units (CPUs), graphics processing units (GPUs), digital signal processors (DSPs),
field-programmable gate arrays (FPGAs, see Section 2.4 for the extreme relevance of this) and other processors or
hardware accelerators.</p>
<p>OpenCL 2.2 brings the OpenCL C++ kernel language into the core specification for significantly enhanced parallel
programming productivity. When releasing OpenCL version 2.2, the Khronos Group announced that OpenCL would
be merging into <a class="reference external" href="https://en.wikipedia.org/wiki/Vulkan_(API)">Vulkan</a> (which targets high-performance realtime
3D graphics applications) in the future, leaving some uncertainty as to how this may affect the HPC space.</p>
</div>
<div class="section" id="runtime-system-approaches">
<h2>Runtime System Approaches<a class="headerlink" href="#runtime-system-approaches" title="Permalink to this headline">¶</a></h2>
<p>As noted already, programming paradigm standards are moving forward to adapt to the technologies that we see in the
market place. The complexity of the hardware infrastructure necessarily brings complexity to the implementation of the
programming standards.</p>
<p>There are number of programming models that leverage runtime systems under development. They promise to abstract
away hardware during the development process, with the proviso that tuning at runtime may be required. Our
experience to date with these systems is limited so we simply provide a list of three such systems here (which is certainly
not exhaustive) in no particular order:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/STEllAR-GROUP/hpx">HPX</a>, a C++ Standard Library for concurrency and parallelism. The goal of the HPX project is to create a high
quality, freely available, open source implementation of <a class="reference external" href="http://stellar.cct.lsu.edu/pubs/icpp09.pdf">ParalleX</a> concepts for conventional and future systems
by building a modular and standards conforming runtime system for SMP and distributed application environments.
(Most recent release: v1.0, April 2017)</li>
<li><a class="reference external" href="https://github.com/kokkos/kokkos">Kokkos</a> implements a programming model in C++ for writing performance portable applications targeting all
major HPC platforms. For that purpose it provides abstractions for both parallel execution of code and data
management. Kokkos is designed to target complex node architectures with N-level memory hierarchies and
multiple types of execution resources. It currently can use OpenMP, Pthreads and CUDA as backend programming
models. (Most recent release: v2.04.04, 11 Sept 2017)</li>
<li><a class="reference external" href="https://pm.bsc.es/ompss">OmpSs</a> is an effort to integrate features from the StarSs programming model developed at Barcelona Supercomputing
Centre (BSC) into a single programming model. In particular, the objective is to extend OpenMP with
new directives to support asynchronous parallelism and heterogeneity (devices like GPUs). However, it can
also be understood as new directives extending other accelerator based APIs like CUDA or OpenCL. The OmpSs
environment is built on top of BSCs Mercurium compiler and Nanos++ runtime system. (Most recent release:
v17.06, June 2017)</li>
</ul>
</div>
<div class="section" id="feedback-for-software-developers">
<h2>Feedback for software developers<a class="headerlink" href="#feedback-for-software-developers" title="Permalink to this headline">¶</a></h2>
<p>Awareness of the latest standards and the status of their implementations are critical at all times during application
development. The adoption of new features from standards are likely to have large impact on the scalability of application
codes precisely because it is very likely that these features exist to target the scalability challenges on modern
systems. Nevertheless, you should be aware that there can be very long gaps between the publication of a standard
and the implementation in compilers (which is frequently also biased by who is pushing which standard and why: Intel
pushes OpenMP because of their Xeon Phi line, NVIDIA who now own PGI pushes OpenACC because of their GPUs,
AMD pushed OpenCL for their own GPUs to compete with CUDA). The likelihood of there being a single common (set
of ) standards that performs well on all architectures is not high in the immediate future. For typical developers that
we see in E-CAM, MPI+OpenMP remains the safest bet and is likely to perform well, as long as the latest standards are
used.</p>
<p>More disruptive software technologies (such as GASNet) are more likely to gain traction if they are used by popular
abstraction layers (which could be PGAS langauages, runtime systems or even domain specific languages) &#8220;under
the hood&#8221;. This would make the transition to new paradigms an implementation issue for the abstraction layer. Indeed,
given the expected complexity of next generation machines, new programming paradigms that help remove the
performance workload from the shoulders of scientific software developers will gain increasing importance.</p>
<p>As you may have noticed in the previous discussion, the computer scientists developing these abstractions are working
mostly in C++, and the implementation of new standards in compilers is also seen first for C++. From a practical
perspective this has some clear implications: if you want to access the latest software technologies then you had better
consider C++ for your application. This may appear harsh given that the Fortran standard has clear capabilities in this
space, but it is a current reality that cannot be ignored. Also, given that the vast majority of researchers will eventually
transition to industry (because there simply aren’t enough permanent jobs in academia) it is more responsible to
ensure they have programming expertise in a language that is heavily used in the commercial space. Finally, the ecosystem
surrounding C++ (IDEs, testing frameworks, libraries,. . . ) is much richer because of it’s use in industry and
computer science.</p>
<p>Taking all of the above into consideration, if you are starting out with an application we would distil the discussion into
the following advice: prototype your application using Python leveraging the Python APIs to the libraries you need;
write unit tests as you go; and, when you start doing computationally intensive work, use C++ with Python interfaces
to allow you to squeeze out maximal performance using the latest software technologies.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/ecam_logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Programming for HPC</a><ul>
<li><a class="reference internal" href="#c-17">C++17</a></li>
<li><a class="reference internal" href="#fortran-2015">Fortran 2015</a></li>
<li><a class="reference internal" href="#the-potential-role-of-python">The (potential) role of Python</a></li>
<li><a class="reference internal" href="#open-standards">Open Standards</a></li>
<li><a class="reference internal" href="#runtime-system-approaches">Runtime System Approaches</a></li>
<li><a class="reference internal" href="#feedback-for-software-developers">Feedback for software developers</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="euro-hardware-roadmap.html"
                        title="previous chapter">Future HPC Hardware in Europe</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="hpc-resources.html"
                        title="next chapter">Accessing HPC Resources in Europe</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/best-practices/hpc/programming-hpc.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="hpc-resources.html" title="Accessing HPC Resources in Europe"
             >next</a> |</li>
        <li class="right" >
          <a href="euro-hardware-roadmap.html" title="Future HPC Hardware in Europe"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">E-CAM Software Library 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Scientific Software Best Practices</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="hpc_programming_guidelines.html" >HPC Programming Guidelines</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, E-CAM Centre of Excellence.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.6.
    </div>
  </body>
</html>